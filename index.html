<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domoducks Family Tree</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f0f0f0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .input-container {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }
        #inscription-id {
            padding: 10px;
            width: 300px;
            font-size: 12px;
            box-sizing: border-box;
        }
        #fetch-btn {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 10px;
        }
        #fetch-btn:hover {
            background-color: #0056b3;
        }
        #error {
            color: red;
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
        }
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        .tree {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            margin: 10px auto;
            max-width: 900px;
            width: 100%;
        }
        .vertical-line {
            position: absolute;
            top: 100px;
            height: 80%;
            left: 50%;
            transform: translateX(-50%);
            width: 1px;
            background: #ccc;
            z-index: -1;
        }
        .level {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 25px;
            margin: 20px 0;
            position: relative;
            width: 100%;
            z-index: 1;
        }
        .level.children {
            gap: 25px;
        }
        .level.single {
            justify-content: center;
        }
        .level.multiple {
            justify-content: center;
        }
        .horizontal-line {
            position: absolute;
            top: 50%;
            width: 60%;
            height: 1px;
            background: #ccc;
            z-index: -1;
        }
        .node {
            border: 1px solid #ccc;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            min-width: 240px;
            max-width: 260px;
            text-align: center;
            box-sizing: border-box;
            position: relative;
            z-index: 2;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .node:hover {
            transform: scale(1.2);
            z-index: 3;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.55);
        }
        .node.non-main {
            min-width: 140px;
            max-width: 180px;
        }
        .node.main {
            border: 5px solid #007bff;
        }
        .node .id {
            word-wrap: break-word;
            word-break: break-all;
            font-size: 10px;
            line-height: 0.8;
            margin-bottom: 5px;
            cursor: pointer;
            color: #007bff;
        }
        .node .id:hover {
            text-decoration: underline;
        }
        .node .label {
            font-size: 12px;
            color: #333;
            margin-top: 4px;
        }
        .node .number {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        .node .satoshi-text {
            font-size: 10px;
            color: #007bff;
            margin-top: 2px;
        }
        .node iframe {
            width: 180px;
            height: 200px;
            border: none;
            background-color: #6e7c96;
            display: block;
            margin: 0 auto;
            object-fit: contain;
        }
        .node.non-main iframe {
            width: 120px;
            height: 120px;
            object-fit: contain;
        }
        .node img {
            width: 180px;
            height: 180px;
            object-fit: contain;
            display: block;
            margin: 0 auto;
            image-rendering: pixelated;
          	background-color: #6f7c96;
        }
        .node.non-main img {
            width: 120px;
            height: 120px;
            background-color: #6f7c96;
          	image-rendering: pixelated;
        }
        .pagination {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .pagination button {
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 3px;
        }
        .pagination button:hover {
            background-color: #0056b3;
        }
        .pagination button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .pagination span {
            padding: 5px 10px;
            font-size: 14px;
            line-height: 1.5;
        }
        .toggle-container {
            margin: 10px;
        }
        .toggle-container label {
            margin-right: 10px;
            font-size: 16px;
        }
        .toggle-container select {
            padding: 5px;
            font-size: 16px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="input-container">
        <div class="toggle-container">
            <label for="network-toggle">Network:</label>
            <select id="network-toggle">
                <option value="ordinals" selected>Ordinals</option>
                <option value="fractals">Fractals</option>
            </select>
        </div>
        <input type="text" id="inscription-id" placeholder="Enter Inscription ID" value="593015b9a76a11554f0a05c3b77a4723c6baaefb8bdd4175712a7320714b8ea8i0">
        <button id="fetch-btn">Fetch Family Tree</button>
        <div id="error"></div>
        <div id="loading" class="loading"></div>
    </div>
    <div class="tree" id="tree">
        <div class="vertical-line"></div>
    </div>

    <script>
        const EXCLUDED_ID = '3076dfe2994ca4b229009eaf5696ad51c4cc68159d13a73a7927a3b8638e411ai0';
        const SATOSHI_ID = '84defb5e7db11f047b4bc58685b65654980be4a55e254a510048a71e0e43e532i0';
        const CHILDREN_PER_PAGE = 16;
        const DEFAULT_ORDINALS_ID = '593015b9a76a11554f0a05c3b77a4723c6baaefb8bdd4175712a7320714b8ea8i0';
        const DEFAULT_FRACTALS_ID = 'a8c39053a557f72619115be77dfeb7bd8506c4d23dee7ddb86d5bc2aea421eeei0';
        let currentPage = 1;
        let allChildrenIds = [];
        let network = 'ordinals';

        async function fetchInscriptionData(id, depth = 0, visited = new Set()) {
    if (id === EXCLUDED_ID) {
        console.log(`Skipping excluded inscription ${id}`);
        return null;
    }

    // Prevent recursive loops
    if (visited.has(id)) {
        console.log(`Inscription ${id}: Recursive reference detected, using placeholder`);
        return {
            id,
            content: 'https://via.placeholder.com/150?text=Recursive+Error',
            isImage: true,
            isHtml: false,
            number: 'N/A',
            parents: [],
            grandparents: [],
            greatGrandparents: [],
            children: []
        };
    }
    visited.add(id);

    const baseUrl = network === 'fractals' ? 'https://ordinals.fractalbitcoin.io' : 'https://ordinals.com';
    const inscriptionUrl = network === 'fractals' ? `https://open-api-fractal.unisat.io/v1/indexer/inscription/info/${id}` : `https://api.hiro.so/ordinals/v1/inscriptions/${id}`;

    try {
        const [contentResponse, parentsResponse, childrenResponse, inscriptionResponse] = await Promise.all([
            fetch(`${baseUrl}/content/${id}`).catch(e => {
                console.error(`Content fetch failed for ${id}:`, e);
                return { ok: false, headers: { get: () => null } };
            }),
            fetch(`${baseUrl}/r/parents/${id}`).catch(e => {
                console.error(`Parents fetch failed for ${id}:`, e);
                return { ok: false };
            }),
            depth === 0 ? fetch(`${baseUrl}/r/children/${id}`).catch(e => {
                console.error(`Children fetch failed for ${id}:`, e);
                return { ok: false };
            }) : { ok: false },
            fetch(inscriptionUrl).catch(e => {
                console.error(`Inscription API fetch failed for ${id}:`, e);
                return { ok: false };
            })
        ]);

        let content = null, isHtml = false, isImage = false;
        if (contentResponse.ok) {
            const contentType = contentResponse.headers.get('content-type');
            console.log(`Inscription ${id} content-type: ${contentType}`);
            if (contentType?.includes('text/html')) {
                const text = await contentResponse.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'text/html');
                const imgTag = doc.querySelector('img');
                if (imgTag?.src) {
                    let src = imgTag.src;
                    // Resolve relative URLs
                    if (!src.startsWith('http')) {
                        src = new URL(src, baseUrl).href;
                    }
                    // Extract inscription ID from src if it matches /content/{id}
                    const match = src.match(/\/content\/([a-f0-9]+i\d+)/);
                    const referencedId = match ? match[1] : null;
                    if (referencedId && referencedId === id) {
                        // Self-referential image
                        content = 'https://via.placeholder.com/150?text=Self-Referential';
                        isImage = true;
                        console.log(`Inscription ${id}: Self-referential image detected, using placeholder`);
                    } else if (referencedId && !visited.has(referencedId)) {
                        // Recursively fetch referenced content
                        const referencedData = await fetchInscriptionData(referencedId, depth + 1, new Set(visited));
                        if (referencedData && referencedData.isImage) {
                            content = referencedData.content;
                            isImage = true;
                            console.log(`Inscription ${id}: Using image from referenced inscription ${referencedId}`);
                        } else {
                            content = src;
                            isImage = true;
                            console.log(`Inscription ${id}: Attempting to load ${src} as image`);
                        }
                    } else {
                        // Try loading as image
                        try {
                            const imgResponse = await fetch(src, { method: 'HEAD' });
                            const imgContentType = imgResponse.headers.get('content-type');
                            if (imgContentType?.includes('image/')) {
                                content = src;
                                isImage = true;
                                console.log(`Inscription ${id}: Resolved image URL ${src}`);
                            } else {
                                content = src;
                                isImage = true;
                                console.log(`Inscription ${id}: Non-image content-type (${imgContentType}), attempting as image`);
                            }
                        } catch (e) {
                            console.error(`Failed to fetch referenced content ${src}:`, e);
                            content = src;
                            isImage = true;
                            console.log(`Inscription ${id}: HEAD request failed, attempting to load ${src} as image`);
                        }
                    }
                } else {
                    // Remove problematic scripts before creating Blob
                    const scripts = doc.querySelectorAll('script[src*="chrome-extension"]');
                    scripts.forEach(script => script.remove());
                    content = URL.createObjectURL(new Blob([doc.documentElement.outerHTML], { type: 'text/html' }));
                    isHtml = true;
                    console.log(`Inscription ${id}: No image tag found or using cleaned HTML content`);
                }
            } else if (contentType?.includes('image/') || contentType === 'application/octet-stream') {
                content = `${baseUrl}/content/${id}`;
                isImage = true;
                console.log(`Inscription ${id}: Direct image content or fallback for octet-stream`);
            } else {
                content = 'https://via.placeholder.com/150?text=Non-Image';
                isImage = true;
                console.log(`Inscription ${id}: Using placeholder image for non-HTML/non-image content`);
            }
        } else {
            content = 'https://via.placeholder.com/150?text=Error';
            isImage = true;
            console.log(`Inscription ${id}: Content fetch failed, using placeholder`);
        }

        const parentsData = parentsResponse.ok ? await parentsResponse.json().catch(e => {
            console.error(`Error parsing parents for ${id}:`, e);
            return { ids: [] };
        }) : { ids: [] };
        const childrenData = depth === 0 && childrenResponse.ok ? await childrenResponse.json().catch(e => {
            console.error(`Error parsing children for ${id}:`, e);
            return { ids: [] };
        }) : { ids: [] };
        const inscriptionData = inscriptionResponse.ok ? await inscriptionResponse.json().catch(e => {
            console.error(`Error parsing Inscription API for ${id}:`, e);
            return { number: null };
        }) : { number: null };

        const filteredParents = Array.isArray(parentsData?.ids) ? parentsData.ids.filter(pid => pid !== EXCLUDED_ID) : [];
        const filteredChildren = Array.isArray(childrenData?.ids) ? childrenData.ids.filter(cid => cid !== EXCLUDED_ID) : [];

        let grandparents = [];
        let greatGrandparents = [];
        if (depth < 1 && filteredParents.length > 0) {
            const grandparentMap = new Map();
            for (const parentId of filteredParents) {
                const parentData = await fetchInscriptionData(parentId, depth + 1, new Set(visited));
                if (parentData) {
                    const grandparentIds = Array.isArray(parentData.parents) ? parentData.parents.filter(gid => gid !== EXCLUDED_ID) : [];
                    for (const gpId of grandparentIds) {
                        if (!grandparentMap.has(gpId)) {
                            const ggData = await fetchInscriptionData(gpId, depth + 2, new Set(visited));
                            if (ggData) {
                                grandparentMap.set(gpId, {
                                    id: gpId,
                                    content: ggData.content,
                                    isHtml: ggData.isHtml,
                                    isImage: ggData.isImage,
                                    number: ggData.number,
                                    parents: ggData.parents
                                });
                            }
                        }
                    }
                }
            }
            grandparents = Array.from(grandparentMap.values());
            if (grandparents.length > 0 && depth < 2) {
                const greatGrandparentMap = new Map();
                for (const grandparent of grandparents) {
                    const greatGrandparentIds = Array.isArray(grandparent.parents) ? grandparent.parents.filter(ggid => ggid !== EXCLUDED_ID) : [];
                    for (const ggId of greatGrandparentIds) {
                        if (!greatGrandparentMap.has(ggId)) {
                            const ggData = await fetchInscriptionData(ggId, depth + 3, new Set(visited));
                            if (ggData) {
                                greatGrandparentMap.set(ggId, {
                                    id: ggId,
                                    content: ggData.content,
                                    isHtml: ggData.isHtml,
                                    isImage: ggData.isImage,
                                    number: ggData.number
                                });
                            }
                        }
                    }
                }
                greatGrandparents = Array.from(greatGrandparentMap.values());
            }
        }

        return {
            id,
            content,
            isHtml,
            isImage,
            number: inscriptionData.number != null ? inscriptionData.number : 'N/A',
            parents: filteredParents,
            grandparents,
            greatGrandparents,
            children: filteredChildren
        };
    } catch (error) {
        console.error(`Error fetching data for ${id}:`, error);
        return {
            id,
            content: 'https://via.placeholder.com/150?text=Error',
            isImage: true,
            number: 'N/A',
            parents: [],
            grandparents: [],
            greatGrandparents: [],
            children: []
        };
    }
}

        function createNode(id, content, isHtml, isImage, levelType, index, number) {
    if (id === EXCLUDED_ID) {
        console.log(`Excluding node for ${id}`);
        return null;
    }

    const node = document.createElement('div');
    node.className = `node ${levelType === 'main' ? 'main' : 'non-main'}`;
    node.dataset.id = id;
    let label = '';
    if (levelType === 'great-grandparent') label = `Great-Grandparent #${index + 1}`;
    else if (levelType === 'grandparent') label = `Grandparent #${index + 1}`;
    else if (levelType === 'parent') label = `Parent #${index + 1}`;
    else if (levelType === 'main') label = 'Main Inscription';
    else if (levelType === 'child') label = `Child #${index + 1}`;
    const satoshiText = id === SATOSHI_ID ? '<div class="satoshi-text">(Sent to Satoshi)</div>' : '';
    const baseUrl = network === 'fractals' ? 'https://ordinals.fractalbitcoin.io' : 'https://ordinals.com';
    node.innerHTML = `
        <span class="id" onclick="buildTree('${id}')">${id}</span>
        ${isImage ? `<img src="${content}" alt="Inscription Content" onerror="this.src='https://via.placeholder.com/150?text=Image+Error';" crossOrigin="anonymous">` : `<iframe src="${content}" title="Inscription Content" sandbox="allow-scripts allow-same-origin"></iframe>`}
        <div class="label">${label}</div>
        <div class="number">#${number}</div>
        ${satoshiText}
    `;
    // Inject base tag for iframe to resolve relative URLs
    if (isHtml) {
        const iframe = node.querySelector('iframe');
        iframe.addEventListener('load', () => {
            const doc = iframe.contentDocument || iframe.contentWindow.document;
            const base = doc.createElement('base');
            base.href = baseUrl;
            doc.head.appendChild(base);
        });
    }
    console.log(`Created node for ${id}, label: ${label}, number: #${number}${id === SATOSHI_ID ? ', with Sent to Satoshi' : ''}`);
    return node;
}

        function renderPagination(totalChildren) {
            const totalPages = Math.ceil(totalChildren / CHILDREN_PER_PAGE);
            const paginationDiv = document.createElement('div');
            paginationDiv.className = 'pagination';

            const prevButton = document.createElement('button');
            prevButton.textContent = 'Previous';
            prevButton.disabled = currentPage === 1;
            prevButton.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderChildrenLevel();
                }
            });
            paginationDiv.appendChild(prevButton);

            const pageSpan = document.createElement('span');
            pageSpan.textContent = `Page ${currentPage} of ${totalPages}`;
            paginationDiv.appendChild(pageSpan);

            const nextButton = document.createElement('button');
            nextButton.textContent = 'Next';
            nextButton.disabled = currentPage === totalPages;
            nextButton.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    renderChildrenLevel();
                }
            });
            paginationDiv.appendChild(nextButton);

            return paginationDiv;
        }

        async function renderChildrenLevel() {
            const childrenLevel = document.getElementById('children-level');
            if (!childrenLevel) return;

            const startIndex = (currentPage - 1) * CHILDREN_PER_PAGE;
            const endIndex = startIndex + CHILDREN_PER_PAGE;
            const paginatedChildIds = allChildrenIds.slice(startIndex, endIndex);

            childrenLevel.innerHTML = '';
            if (paginatedChildIds.length > 1) {
                childrenLevel.innerHTML = '<div class="horizontal-line"></div>';
            }
            if (paginatedChildIds.length > 0) {
                let index = startIndex;
                for (const childId of paginatedChildIds) {
                    const childData = await fetchInscriptionData(childId, 1);
                    if (childData) {
                        const node = createNode(childId, childData.content, childData.isHtml, childData.isImage, 'child', index, childData.number);
                        if (node) childrenLevel.appendChild(node);
                        index++;
                    }
                }
            } else {
                childrenLevel.innerHTML = '<div>No Children</div>';
            }

            const existingPagination = document.getElementById('pagination');
            if (existingPagination) existingPagination.remove();
            if (allChildrenIds.length > CHILDREN_PER_PAGE) {
                const paginationDiv = renderPagination(allChildrenIds.length);
                paginationDiv.id = 'pagination';
                childrenLevel.parentNode.insertBefore(paginationDiv, childrenLevel.nextSibling);
            }
        }

        async function buildTree(inscriptionId) {
            const tree = document.getElementById('tree');
            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');
            tree.innerHTML = '<div class="vertical-line"></div>';
            errorDiv.textContent = '';
            errorDiv.style.display = 'none';
            loadingDiv.style.display = 'block';
            currentPage = 1;
            allChildrenIds = [];
            document.getElementById('inscription-id').value = inscriptionId;

            if (inscriptionId === EXCLUDED_ID) {
                errorDiv.textContent = 'This inscription ID is excluded from display.';
                errorDiv.style.display = 'block';
                loadingDiv.style.display = 'none';
                return;
            }

            try {
                const data = await fetchInscriptionData(inscriptionId);
                if (!data) throw new Error('No data returned for inscription');

                // Great-Grandparents level
                const greatGrandparentsLevel = document.createElement('div');
                greatGrandparentsLevel.className = `level ${data.greatGrandparents.length === 1 ? 'single' : data.greatGrandparents.length > 1 ? 'multiple' : ''}`;
                if (data.grandparents.length > 0) {
                    if (data.greatGrandparents.length > 1) {
                        greatGrandparentsLevel.innerHTML = '<div class="horizontal-line"></div>';
                    }
                    if (data.greatGrandparents.length > 0) {
                        let index = 0;
                        for (const greatGrandparent of data.greatGrandparents) {
                            const node = createNode(greatGrandparent.id, greatGrandparent.content, greatGrandparent.isHtml, greatGrandparent.isImage, 'great-grandparent', index, greatGrandparent.number);
                            if (node) greatGrandparentsLevel.appendChild(node);
                            index++;
                        }
                    } else {
                        greatGrandparentsLevel.innerHTML = '<div>No Great-Grandparents</div>';
                    }
                    tree.appendChild(greatGrandparentsLevel);
                }

                // Grandparents level
                const grandparentsLevel = document.createElement('div');
                grandparentsLevel.className = `level ${data.grandparents.length === 1 ? 'single' : data.grandparents.length > 1 ? 'multiple' : ''}`;
                if (data.grandparents.length > 1) {
                    grandparentsLevel.innerHTML = '<div class="horizontal-line"></div>';
                }
                if (data.grandparents.length > 0) {
                    let index = 0;
                    for (const grandparent of data.grandparents) {
                        const node = createNode(grandparent.id, grandparent.content, grandparent.isHtml, grandparent.isImage, 'grandparent', index, grandparent.number);
                        if (node) grandparentsLevel.appendChild(node);
                        index++;
                    }
                } else {
                    grandparentsLevel.innerHTML = '<div>No Grandparents</div>';
                }
                tree.appendChild(grandparentsLevel);

                // Parents level
                const parentsLevel = document.createElement('div');
                parentsLevel.className = `level ${data.parents.length === 1 ? 'single' : data.parents.length > 1 ? 'multiple' : ''}`;
                if (data.parents.length > 1) {
                    parentsLevel.innerHTML = '<div class="horizontal-line"></div>';
                }
                if (data.parents.length > 0) {
                    let index = 0;
                    for (const parentId of data.parents) {
                        const parentData = await fetchInscriptionData(parentId, 1);
                        if (parentData) {
                            const node = createNode(parentId, parentData.content, parentData.isHtml, parentData.isImage, 'parent', index, parentData.number);
                            if (node) parentsLevel.appendChild(node);
                            index++;
                        }
                    }
                } else {
                    parentsLevel.innerHTML = '<div>No Parents</div>';
                }
                tree.appendChild(parentsLevel);

                // Main node level
                const mainLevel = document.createElement('div');
                mainLevel.className = 'level single';
                const mainNode = createNode(inscriptionId, data.content, data.isHtml, data.isImage, 'main', 0, data.number);
                if (mainNode) mainLevel.appendChild(mainNode);
                tree.appendChild(mainLevel);

                // Children level
                const childrenLevel = document.createElement('div');
                childrenLevel.className = `level children ${data.children.length === 1 ? 'single' : data.children.length > 1 ? 'multiple' : ''}`;
                childrenLevel.id = 'children-level';
                tree.appendChild(childrenLevel);
                allChildrenIds = data.children;
                await renderChildrenLevel();

            } catch (error) {
                console.error('Build error:', error);
                errorDiv.textContent = `Failed to build tree: ${error.message}`;
                errorDiv.style.display = 'block';
            } finally {
                loadingDiv.style.display = 'none';
            }
        }

        document.getElementById('fetch-btn').addEventListener('click', () => {
            const inscriptionId = document.getElementById('inscription-id').value.trim();
            if (inscriptionId) {
                buildTree(inscriptionId);
            } else {
                const errorDiv = document.getElementById('error');
                errorDiv.textContent = 'Please enter a valid Inscription ID';
                errorDiv.style.display = 'block';
            }
        });

        document.getElementById('network-toggle').addEventListener('change', (event) => {
            network = event.target.value;
            const inscriptionId = network === 'fractals' ? DEFAULT_FRACTALS_ID : DEFAULT_ORDINALS_ID;
            document.getElementById('inscription-id').value = inscriptionId;
            buildTree(inscriptionId);
        });

        window.onload = () => {
            const inscriptionId = document.getElementById('inscription-id').value.trim();
            if (inscriptionId) {
                buildTree(inscriptionId);
            }
        };
    </script>
</body>
</html>
